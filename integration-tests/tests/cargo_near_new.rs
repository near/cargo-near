use std::process::{Command, Stdio};

use camino::Utf8PathBuf;
use serde_json::json;
mod crate_metadata;
mod toolchain_channels;
use cargo_near_integration_tests::setup_tracing;

/// tests logic of `../../cargo-near/src/commands/new/new-project-template/tests/test_basics.rs`,
/// on contract, generated by `cargo near new`, which is then built for tests by [cargo_near_build::docker::build]
#[cfg(target_os = "linux")]
#[tokio::test]
async fn test_docker_build() -> Result<(), Box<dyn std::error::Error>> {
    setup_tracing();

    let generated_manifest = run_cargo_near_new()?;
    crate_metadata::assert_versions_equal(
        &tests_manifest(),
        &generated_manifest,
        "near_workspaces",
    )?;

    let opts = cargo_near_build::docker::DockerBuildOpts::builder()
        .manifest_path(generated_manifest.clone())
        .context(cargo_near_build::BuildContext::Build)
        .build();

    let artifact = cargo_near_build::docker::build(opts)?;

    let contract_wasm = std::fs::read(artifact.path)?;

    test_basics_on(&contract_wasm).await?;

    std::fs::remove_dir_all(
        generated_manifest
            .parent()
            .expect("expected to have parent"),
    )?;

    Ok(())
}

// this item ensures that tests of this module share logic of `test_basics_on`
// with `../../cargo-near/src/commands/new/new-project-template/tests/test_basics.rs`
include! {"../../cargo-near/src/commands/new/test_basics_on.rs.in"}

/// This runs `cargo test` on project, generated by `cargo near new`
#[test]
fn test_cargo_test_on_generated_project() -> Result<(), Box<dyn std::error::Error>> {
    let generated_manifest = run_cargo_near_new()?;

    toolchain_channels::assert_equal(
        &tests_toolchain(),
        &generated_manifest
            .parent()
            .expect("has a parent")
            .join("rust-toolchain.toml"),
    )?;

    // somehow `rustup` doesn't respect `rust-toolchain.toml` in
    // the target generated dir
    let mut cmd = Command::new("cargo");
    cmd.arg("test")
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .current_dir(
            generated_manifest
                .parent()
                .expect("expected to have parent")
                .as_str(),
        );

    let (output, output_string) = {
        let child = cmd.spawn()?;
        let output = child.wait_with_output()?;
        let mut output_string = String::new();
        output_string.push_str(&String::from_utf8_lossy(&output.stderr));
        output_string.push_str(&String::from_utf8_lossy(&output.stdout));
        (output, output_string)
    };

    assert!(
        output.status.success(),
        "running `cargo test` errored with msg: {}",
        output_string
    );

    std::fs::remove_dir_all(
        generated_manifest
            .parent()
            .expect("expected to have parent"),
    )?;

    Ok(())
}

/// tests logic of `../../cargo-near/src/commands/new/new-project-template/tests/test_basics.rs`,
/// on contract, generated by `cargo near new`, which is then built for tests by [cargo_near_build::build]
///
/// differs from [test_cargo_test_on_generated_project] in the aspect, that current test
/// uses [cargo_near_build::build] from current *cargo-near* branch, whereas
/// [test_cargo_test_on_generated_project] uses [cargo_near_build::build] logic from
/// latest published [near_workspaces::compile_project]  
#[tokio::test]
async fn test_regular_build() -> Result<(), Box<dyn std::error::Error>> {
    setup_tracing();

    let generated_manifest = run_cargo_near_new()?;
    crate_metadata::assert_versions_equal(
        &tests_manifest(),
        &generated_manifest,
        "near_workspaces",
    )?;
    toolchain_channels::assert_equal(
        &tests_toolchain(),
        &generated_manifest
            .parent()
            .expect("has a parent")
            .join("rust-toolchain.toml"),
    )?;

    let opts = cargo_near_build::BuildOpts::builder()
        .manifest_path(generated_manifest.clone())
        .build();

    let artifact = cargo_near_build::build(opts)?;

    let contract_wasm = std::fs::read(artifact.path)?;

    test_basics_on(&contract_wasm).await?;

    std::fs::remove_dir_all(
        generated_manifest
            .parent()
            .expect("expected to have parent"),
    )?;

    Ok(())
}

/// runs a `cargo near new FOLDER` routine while returning the FOLDER/Cargo.toml
fn run_cargo_near_new() -> color_eyre::Result<camino::Utf8PathBuf> {
    let out_path = {
        let tmp_dir = tempfile::Builder::new()
            .prefix("cargo_near_new_")
            .tempdir()?;
        tmp_dir.path().to_owned()
    };

    let scope = cargo_near::commands::new::InteractiveClapContextScopeForNew {
        project_dir: out_path.clone().into(),
    };
    let _result = cargo_near::commands::new::NewContext::from_previous_context(
        cargo_near::GlobalContext {
            config: Default::default(),
            offline: false,
            teach_me: false,
        },
        &scope,
    )?;
    let out_path: Utf8PathBuf = out_path.try_into()?;
    Ok(out_path.join("Cargo.toml"))
}

fn tests_manifest() -> camino::Utf8PathBuf {
    let cargo_near_integration_tests_dir: camino::Utf8PathBuf = env!("CARGO_MANIFEST_DIR").into();
    cargo_near_integration_tests_dir.join("Cargo.toml")
}

fn tests_toolchain() -> camino::Utf8PathBuf {
    let cargo_near_integration_tests_dir: camino::Utf8PathBuf = env!("CARGO_MANIFEST_DIR").into();
    cargo_near_integration_tests_dir.join("../rust-toolchain.toml")
}
