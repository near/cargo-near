use colored::Colorize;

use crate::types::cargo::manifest_path::ManifestPath;

impl super::Opts {
    pub fn contract_path(&self) -> eyre::Result<camino::Utf8PathBuf> {
        let contract_path: camino::Utf8PathBuf = if let Some(manifest_path) = &self.manifest_path {
            let manifest_path = ManifestPath::try_from(manifest_path.clone())?;
            manifest_path.directory()?.to_path_buf()
        } else {
            camino::Utf8PathBuf::from_path_buf(std::env::current_dir()?)
                .map_err(|err| eyre::eyre!("Failed to convert path {}", err.to_string_lossy()))?
        };
        Ok(contract_path)
    }

    const BUILD_COMMAND_CLI_CONFIG_ERR: &'static str =  "flag cannot be used, when `container_build_command` is configured from `[package.metadata.near.reproducible_build]` in Cargo.toml";

    pub fn get_cli_build_command_in_docker(
        &self,
        manifest_command: Option<Vec<String>>,
        passed_env: Option<Vec<String>>,
    ) -> eyre::Result<Vec<String>> {
        if let Some(manifest_command) = manifest_command {
            self.append_env_suffix(manifest_command, passed_env)
        } else {
            println!(
                "{}",
                "configuring `container_build_command` from cli args, passed to current command"
                    .cyan()
            );
            println!();
            Ok(self.passthrough_some_opts_into_docker_cmd())
        }
    }

    fn append_env_suffix(
        &self,
        mut manifest_command: Vec<String>,
        passed_env: Option<Vec<String>>,
    ) -> eyre::Result<Vec<String>> {
        self.check_flag_conflicts_with_manifest_command()?;
        if let Some(passed_env) = passed_env {
            let suffix_env = passed_env
                .into_iter()
                .filter(|env_key| std::env::var(env_key).is_ok())
                .flat_map(|env_key| {
                    println!(
                        "{}{}{}",
                        "detected environment build parameter, which has been set: `".cyan(),
                        env_key.yellow(),
                        "`".cyan(),
                    );
                    let value = std::env::var(&env_key).unwrap();
                    let pair = [env_key, value].join("=");
                    ["--env".to_string(), pair]
                })
                .collect::<Vec<_>>();

            if !suffix_env.is_empty() {
                println!(
                    "{}{}{}",
                    "(listed in `".cyan(),
                    "passed_env".yellow(),
                    "` from `[package.metadata.near.reproducible_build]` in Cargo.toml)".cyan(),
                );
                println!();
            }

            manifest_command.extend(suffix_env);
        }

        Ok(manifest_command)
    }

    fn passthrough_some_opts_into_docker_cmd(&self) -> Vec<String> {
        let mut cli_args: Vec<String> = vec![];
        // NOTE: not passing through `no_locked` to cmd in container,
        // an invisible Cargo.lock was generated by implicit `cargo metadata` anyway
        // if self.no_locked {
        //     no-op
        // }

        cli_args.extend(self.no_release.then_some("--no-release".into()));
        cli_args.extend(self.no_abi.then_some("--no-abi".into()));
        cli_args.extend(self.no_embed_abi.then_some("--no-embed-abi".into()));
        cli_args.extend(self.no_doc.then_some("--no-doc".into()));
        cli_args.extend(self.no_wasmopt.then_some("--no-wasmopt".into()));

        if let Some(ref features) = self.features {
            cli_args.extend(["--features".into(), features.clone()]);
        }
        cli_args.extend(
            self.no_default_features
                .then_some("--no-default-features".into()),
        );
        if let Some(ref color) = self.color {
            cli_args.extend(["--color".into(), color.to_string()]);
        }
        cli_args.extend(self.env.clone().into_iter().flat_map(|(key, value)| {
            let equal_pair = [key, value].join("=");
            ["--env".to_string(), equal_pair]
        }));

        let mut cli_command_prefix = self.cli_description.cli_command_prefix.clone();
        cli_command_prefix.extend(cli_args);
        cli_command_prefix
    }
    fn check_flag_conflicts_with_manifest_command(&self) -> eyre::Result<()> {
        // NOTE: `--no-locked` is allowed for docker builds
        // if self.no_locked {
        //     no-op
        // }
        if self.no_release {
            return Err(eyre::eyre!(format!(
                "`{}` {}",
                "--no-release",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR
            )));
        }
        if self.no_abi {
            return Err(eyre::eyre!(format!(
                "`{}` {}",
                "--no-abi",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR
            )));
        }
        if self.no_embed_abi {
            return Err(eyre::eyre!(format!(
                "`{}` {}",
                "--no-embed-abi",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR
            )));
        }
        if self.no_doc {
            return Err(eyre::eyre!(format!(
                "`{}` {}",
                "--no-doc",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR
            )));
        }
        if self.no_wasmopt {
            return Err(eyre::eyre!(format!(
                "`{}` {}",
                "--no-wasmopt ",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR
            )));
        }
        if self.features.is_some() {
            return Err(eyre::eyre!(format!(
                "`{}` {}",
                "--features",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR
            )));
        }
        if self.no_default_features {
            return Err(eyre::eyre!(format!(
                "`{}` {}",
                "--no-default-features",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR
            )));
        }
        if !self.env.is_empty() {
            return Err(eyre::eyre!(format!(
                "`{}` {}\n{}",
                "--env",
                Self::BUILD_COMMAND_CLI_CONFIG_ERR,
                "You can specify environment vars in `passed_env` list in `[package.metadata.near.reproducible_build]` instead"
            )));
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_passthrough_some_opts_into_docker_cmd() {
        let opts = crate::BuildOpts {
            no_release: true,
            no_abi: true,
            no_embed_abi: true,
            no_doc: true,
            features: Some("cool_feature".into()),
            no_default_features: true,
            color: Some(crate::ColorPreference::Always),
            ..Default::default()
        };

        assert_eq!(
            opts.passthrough_some_opts_into_docker_cmd(),
            vec![
                "cargo".to_string(),
                "near".to_string(),
                "build".to_string(),
                "--no-release".to_string(),
                "--no-abi".to_string(),
                "--no-embed-abi".to_string(),
                "--no-doc".to_string(),
                "--features".to_string(),
                "cool_feature".to_string(),
                "--no-default-features".to_string(),
                "--color".to_string(),
                "always".to_string()
            ],
        );
    }
}
